# -*- coding: utf-8 -*-
"""Manual_TA_Algo(Crypto)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w64ck2qzPeroITxDCeihqgJqmk4lVzgU
"""

!pip install pandas-datareader
!pip install --upgrade ta
!pip install -U git+https://github.com/twopirllc/pandas-ta
!pip install nest-asyncio
!pip install -U git+https://github.com/mariostoev/finviz
!pip install git+git://github.com/peerchemist/finta.git
!pip install tiingo
 
#!pip install pandas_ta
#!pip install robin_stocks
!pip install finviz
!pip install PyPortfolioOpt 
#!pip install yfinance
!pip install -U yfinance
 
!pip install scikit-learn==0.23.
!pip install portfoliolab
!pip install --upgrade numpy
!pip install pandas==1.3.0
 
import pandas_ta

!pip install cbpro
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import pandas_datareader.data as pdr
import ta

from pandas import DataFrame, Series
import nest_asyncio
nest_asyncio.apply()
import finviz
from finviz.screener import Screener
from finta import TA

from tiingo import TiingoClient
import requests

from statistics import mean,median
import urllib
from urllib.parse import urlencode, quote_plus
import pypfopt
from pypfopt import objective_functions
 
from google.colab import files
import csv
from collections import OrderedDict
import json
 
#import robin_stocks as rs
from dateutil import parser
import scipy
from scipy import stats as scipy_stats

 
import yfinance as yf
yf.pdr_override()
 

import requests
import datetime as dt
from statistics import mean,median
import urllib
from urllib.parse import urlencode, quote_plus
 
from sklearn.preprocessing import MinMaxScaler

import sklearn

import cbpro
import base64
import json
from time import sleep


import warnings
warnings.simplefilter("ignore")

# Commented out IPython magic to ensure Python compatibility.
import cython
# %load_ext cython

#cython
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import pandas_datareader.data as pdr
import ta
import pandas_ta 
from pandas import DataFrame, Series
import nest_asyncio
nest_asyncio.apply()
import finviz
from finviz.screener import Screener
from finta import TA
import tiingo
from tiingo import TiingoClient
import requests
 
from statistics import mean,median
import urllib
from urllib.parse import urlencode, quote_plus
import pypfopt
from pypfopt import objective_functions
 
from google.colab import files
import csv
from collections import OrderedDict
import json
 
#import robin_stocks as rs
from dateutil import parser
import scipy
from scipy import stats as scipy_stats
 
import yfinance as yf
yf.pdr_override()
 

 
import requests
import datetime as dt
from statistics import mean,median
import urllib
from urllib.parse import urlencode, quote_plus
 
import cbpro
import base64
import json
from time import sleep
from sklearn.preprocessing import MinMaxScaler
 
import sklearn
 
import warnings
warnings.simplefilter("ignore")
 
def yahooTA(ticker,freq):
  
  sixty=['1m','2m','5m','15m','30m','15m']
 
  if freq in sixty:
    data=pdr.get_data_yahoo(ticker,interval=freq,period='60d')
    data.index=data.index.tz_convert('US/Pacific')
  
  elif freq=='1h':
    data=pdr.get_data_yahoo(ticker,interval=freq,period='710d')
    data.index=data.index.tz_convert('US/Pacific')
  
  else:
    #data=pdr.get_data_yahoo(ticker,interval=freq)
    data=pdr.get_data_yahoo(ticker,interval=freq,period='360d')
   
  data=data.drop('Adj Close',axis=1)
  #data=data.reset_index()
  
  data['mfi2']=ta.volume.money_flow_index(high=data['High'],low=data['Low'],close=data['Close'],volume=data['Volume'],window=2)
  data['mfi10']=ta.volume.money_flow_index(high=data['High'],low=data['Low'],close=data['Close'],volume=data['Volume'],window=10)
  
  data['rsi10']=ta.momentum.rsi(close=data['Close'],window=10)
  data['rsi2']=ta.momentum.rsi(close=data['Close'],window=2)            
 
  data['hma10']=pandas_ta.hma(data['Close'],length=10)
  data['hma20']=pandas_ta.hma(data['Close'],length=20)
  data['hma50']=pandas_ta.hma(data['Close'],length=50)
  #data['hma150']=pandas_ta.hma(data['Close'],length=150)
  #data['ema200']=ta.trend.ema_indicator(data['Close'],window=200)
  data['ema10']=pandas_ta.ema(data['Close'],length=10)
  data['ema20']=pandas_ta.ema(data['Close'],length=20)
  data['ema50']=pandas_ta.ema(data['Close'],length=50)
 
  #data['natr']=pandas_ta.natr(data['High'],data['Low'],data['Close'],length=10)
 
  psar=pandas_ta.psar(data['High'],data['Low'],data['Close'],0.4,0.4,0.4)
    
  psar['PSARl_0.4_0.4'].fillna(psar['PSARs_0.4_0.4'],inplace=True)
  data['psar']=psar['PSARl_0.4_0.4']
 
  psar=pandas_ta.psar(data['High'],data['Low'],data['Close'],2,2,2)
 
  psar['PSARl_2.0_2.0'].fillna(psar['PSARs_2.0_2.0'],inplace=True)
  data['stop_loss']=psar['PSARl_2.0_2.0']
 
  data['hbb']=ta.volatility.bollinger_hband(data['Close'])
  data['lbb']=ta.volatility.bollinger_lband(data['Close'])
     
  data['close_returns']=data.Close.pct_change(periods=1)
  data['price_roc']=data.Close.diff()
  data['vol_roc']=data.Volume.diff().ewm(span=10).mean()
 
  data['Volume'].iloc[:data['hma10'].isnull().sum()]=data['hma10'].iloc[:data['hma10'].isnull().sum()]
 
  data['vol_ema']=data['Volume'].ewm(span=10).mean()
 
  keltner=pandas_ta.kc(data['High'],data['Low'],data['Close'],scale=1.5,mamode='ema')
  keltner.columns=['lkeltner','mkeltner','hkeltner']  
 
  data=pd.concat([data,keltner],axis=1)
  
  data.columns=[col.lower() for col in data.columns]
 
  data['cci10']=pandas_ta.cci(data['low'],data['high'],data['close'],length=10)
  data['cci2']=pandas_ta.cci(data['low'],data['high'],data['close'],length=2)
 
  #data['qstick10']=pandas_ta.qstick(data['open'],data['close'],length=10)
  #data['qstick2']=pandas_ta.qstick(data['open'],data['close'],length=2)
 

  #data['kvo']=pandas_ta.kvo(data['high'],data['low'],data['close'],data['volume'],fast=20,long=50,length_sig=10)['KVOs_20_55_13']
  #data['eri']=pandas_ta.eri(data['high'],data['low'],data['close'],length=10)
  
  return data
 
def Prices(stocks_list,freq):
 
  prices_df=pd.DataFrame()
  sixty=['1m','2m','5m','30m','15m']
  
  for ticker in stocks_list:
    
    if freq in sixty:
      data=pdr.get_data_yahoo(ticker,interval=freq,period='60d')
      data.index=data.index.tz_convert('US/Pacific')
    
    elif freq=='1h':
      data=pdr.get_data_yahoo(ticker,interval=freq,period='710d')
      data.index=data.index.tz_convert('US/Pacific')
    
    else:
      data=pdr.get_data_yahoo(ticker,interval=freq)
      
    prices_df[str(ticker)]=data['Close']
      
      #prices_df=prices_df.dropna(axis=0)
 
  return prices_df
 
def Last_Prices(ticker_list,freq):
  sixty=['1m','2m','5m','30m','15m']
  price_series=pd.Series()
 
  for ticker in ticker_list:
    
    if freq in sixty:
      data=pdr.get_data_yahoo(ticker,interval=freq,period='60d')
      data.index=data.index.tz_convert('US/Pacific')
    
    elif freq=='1h':
      data=pdr.get_data_yahoo(ticker,interval=freq,period='710d')
      data.index=data.index.tz_convert('US/Pacific')
    
    else:
      data=pdr.get_data_yahoo(ticker,interval=freq)
  
    price_series[ticker]=data.Close.iloc[-1]
 
  return price_series
 
def yf_fetch(ticker_list):
 
  returns_df=pd.DataFrame()
  prices_df=pd.DataFrame()
 
  for ticker in ticker_list:
    data=yf.Ticker(ticker).history(period='max')
   
    data['returns']=data.Close.pct_change()
 
    returns_df[str(ticker)]=data['returns']
    prices_df[str(ticker)]=data['Close']
  
  return returns_df,prices_df
 
def yf_intraday(ticker_list):
  returns_df=pd.DataFrame()
  prices_df=pd.DataFrame()
 
  for ticker in ticker_list:
    data=yf.Ticker(ticker).history(period='60d',interval='15m')
    data['returns']=data.Close.pct_change()
 
    returns_df[str(ticker)]=data['returns']
    prices_df[str(ticker)]=data['Close']
 
  return returns_df,prices_df
 
def Returns(stocks_list):
 
  returns_df=pd.DataFrame()
  
  for stock_symbol in stocks_list:
     
    data=pdr.get_data_yahoo(stock_symbol.replace('.',''))
    
    returns_df[str(stock_symbol)]=data['Close'].pct_change()
    
    #prices_df=prices_df.dropna(axis=0)
 
  return returns_df
 
def Blacklitter(prices_df,views_dict):
  view_series=pd.Series(views_dict)
  view_series=view_series[view_series!=0]
  hrp_weights=HR_Paritize(prices_df,views_dict)
  hrp_series=pd.Series(hrp_weights) 

  risk_model=pypfopt.risk_models.CovarianceShrinkage(prices_df)
  cov_matrix=risk_model.oracle_approximating()

  repeat=np.array(hrp_series-1/len(hrp_series))
  P=np.vstack([repeat]*len(view_series))
  Q=np.array(view_series).reshape(-1,1)

  bl=pypfopt.black_litterman.BlackLittermanModel(cov_matrix=cov_matrix,Q=Q,P=P)
  weights=bl.bl_weights()
  weights=bl.clean_weights(cutoff=0.000001,rounding=8)

  if np.isinf(pd.Series(weights)).sum()==len(weights):
    one_df=pd.Series([1 if x>0 else -1 for x in pd.Series(weights)],index=weights.keys())
    
    one_df=one_df/(abs(one_df)).sum()
    weights=dict(one_df)

  return dict(weights)

def Blacklitter1(prices_df,view_dict):
  risk_model=pypfopt.risk_models.CovarianceShrinkage(prices_df)
  cov_matrix=risk_model.oracle_approximating()
 
  view_series=pd.Series(view_dict)
 
  #cov_matrix=pypfopt.risk_models.fix_nonpositive_semidefinite(cov_matrix,fix_method='spectral')
 
  #if np.linalg.det(cov_matrix)==0:
    #cov_matrix=cov_matrix+0.0000001
  
  bl=pypfopt.black_litterman.BlackLittermanModel(cov_matrix=cov_matrix,absolute_views=view_series)
 
  weights=bl.bl_weights()
  weights=bl.clean_weights(cutoff=0.000001,rounding=8)
 
  return dict(weights)
 
def HR_Paritize(prices_df,views_dict):

  if len(views_dict)==1:
    return {x:1 for x in views_dict}
  
  elif len(views_dict)==0:
    return {}
  
  else:
    
    views_df=pd.Series(views_dict)

    prices_df=prices_df[views_df.index]

    risk_model=pypfopt.risk_models.CovarianceShrinkage(prices_df)
    cov_matrix=risk_model.oracle_approximating()

    hrp=pypfopt.hierarchical_portfolio.HRPOpt(cov_matrix=cov_matrix)

    abs_weights=dict(hrp.optimize())
    
    return abs_weights
 
def norm(x):
    
    nom = (x - x.min())*1.33
    denom = x.max() - x.min()
    return  nom/denom
 
def tanm(x):
  e=2.71828
  numerator=(e**(15*x)-e**(7.5))
  denominator=(e**(15*x)+e**(7.5))**-1
 
  if isinstance(x,float)==True:
    if np.isnan(numerator * denominator)==True:
      return 1
    
    else:
      return numerator*denominator
    
  else:
    return numerator*denominator
 
def as_currency(amount):
  
    if amount >= 0:
        return float('{:.2f}'.format(amount))
    else:
        return float('-{:.2f}'.format(-amount))
 
def bband(data):
  if (data['high'].iloc[-1]>data['hbb'].iloc[-1] and data['close'].iloc[-1]>data['hbb'].iloc[-1]) or (data['low'].iloc[-1]<data['lbb'].iloc[-1] and data['close'].iloc[-1]>data['hbb'].iloc[-1]):
    return 1
  
  elif (data['high'].iloc[-1]>data['hbb'].iloc[-1] and data['close'].iloc[-1]<data['hbb'].iloc[-1]) or (data['low'].iloc[-1]<data['lbb'].iloc[-1] and data['close'].iloc[-1]<data['hbb'].iloc[-1]):
    return -1
  
  else:
    return 0
 
def supertrend(data):
  data['super']=pandas_ta.supertrend(data['high'],data['low'],data['close'],length=2,multiplier=1).iloc[:,1]
  
  return data['super'].iloc[-1]/2
 
def mfi2(data):
  return -0.5*(data['mfi2'].iloc[-1]>=95)+0.5*(data['mfi2'].iloc[-1]<=5)
 
def rsi2(data):
  return -0.5*(data['rsi2'].iloc[-1]>=95)+0.5*(data['rsi2'].iloc[-1]<=5)
 
def cci2(data):
  return -0.5*(data['cci2'].iloc[-1]>=65)+0.5*(data['cci2'].iloc[-1]<=-65)
 
def mfi10(data):
  if psar_trend(data)==1 and (data['mfi10'].iloc[-1]>=90 or data['mfi10'].iloc[-1]<=40):
    return tanm(1-data['mfi10'].iloc[-1]/100)
  
  elif psar_trend(data)==-1 and (data['mfi10'].iloc[-1]>=60 or data['mfi10'].iloc[-1]<=10):
    return tanm(1-data['mfi10'].iloc[-1]/100)
  
  else:
    return 0
 
def rsi10(data):
  if psar_trend(data)==1 and (data['rsi10'].iloc[-1]>=80 or data['rsi10'].iloc[-1]<=35):
    return tanm(1-data['rsi10'].iloc[-1]/100)
  
  elif psar_trend(data)==-1 and (data['rsi10'].iloc[-1]>=60 or data['rsi10'].iloc[-1]<=25):
    return tanm(1-data['rsi10'].iloc[-1]/100)
  
  else:
    return 0
 
def cci10(data):
  if psar_trend(data)==-1 and (data['cci10'].iloc[-1]>=100):
    return tanm(1-data['cci10'].iloc[-1]/100)
  
  elif psar_trend(data)==1 and (data['cci10'].iloc[-1]<=-100):
    return tanm(1-data['cci10'].iloc[-1]/100)
  
  else:
    return 0
 
def hma_crossback(data):
  if data['close'].iloc[-1]>=data['hma50'].iloc[-1] and data['hma10'].iloc[-1]>=data['hma20'].iloc[-1] and data['hma10'].iloc[-2]<=data['hma20'].iloc[-2]:
    return 1
  elif data['close'].iloc[-1]<=data['hma50'].iloc[-1] and data['hma10'].iloc[-1]<=data['hma20'].iloc[-1] and data['hma10'].iloc[-2]>=data['hma20'].iloc[-2]:
    return -1
  else:
    return 0
 
def ema_crossback(data):
  if data['close'].iloc[-1]>=data['ema50'].iloc[-1] and data['ema10'].iloc[-1]>=data['ema20'].iloc[-1] and data['ema10'].iloc[-2]<=data['ema20'].iloc[-2]:
    return 1
  elif data['close'].iloc[-1]<=data['ema50'].iloc[-1] and data['ema10'].iloc[-1]<=data['ema20'].iloc[-1] and data['ema10'].iloc[-2]>=data['ema20'].iloc[-2]:
    return -1
  else:
    return 0
 
def psar_reversal(data):
  if data['close'].iloc[-1]>data['psar'].iloc[-1] and data['close'].iloc[-2]<data['psar'].iloc[-2]:
    return 1
  
  elif data['close'].iloc[-1]<data['psar'].iloc[-1] and data['close'].iloc[-2]>data['psar'].iloc[-2]:
    return -1
    
  else:
    return 0
 
def squeezed(data):
  if data['hbb'].iloc[-1]>data['hkeltner'].iloc[-1] and data['lbb'].iloc[-1]<data['lkeltner'].iloc[-1]:
    return 1
  
  elif data['hbb'].iloc[-1]<data['hkeltner'].iloc[-1] and data['lbb'].iloc[-1]>data['lkeltner'].iloc[-1]:
    return -1
  
  else:
    return 0
 
def volume_counter(data):
  orig_data=data.copy()
  data=data[['volume','vol_ema','close_returns']].iloc[-10:]
 
  data['label']=0
  data['label'][data['close_returns']>0]=1
  data['label'][data['close_returns']<0]=-1
 
  plus_counter=0
  neg_counter=0
 
  for idx in range(len(data)):
    if data['label'].iloc[idx]==1 and data['volume'].iloc[idx]>=data['vol_ema'].iloc[idx]:
      plus_counter+=1
    
    elif data['label'].iloc[idx]==-1 and data['volume'].iloc[idx]>=data['vol_ema'].iloc[idx]:
      neg_counter+=1
    
    else:
      continue
 
  sum_counter=plus_counter-neg_counter
  if (sum_counter>0 and plus_counter>=3) and (psar_trend(orig_data)==1):
    
    return scipy.special.expit(sum_counter)
 
  elif (sum_counter<0 and neg_counter>=3) and (psar_trend(orig_data)==-1):
    return scipy.special.expit(sum_counter)
 
  else:
    return 0
 
def momentum(data):
  squeeze=squeezed(data)*psar_trend(data)
  roc=data['price_roc'].iloc[-5:].mean()
  
  if (squeeze==1) or (squeeze==-1):
    
    return scipy.special.expit(roc)
  
  else:
    return 0
 
def ichimoku(data):
 
  past,future=pandas_ta.ichimoku(data['high'],data['low'],data['close'])
  past.columns=['spanA','spanB','conversion','base','lag']
  past=past.drop(['lag'],axis=1)
  future.columns=['spanA','spanB']
 
  ichimoku_df=past.append(future)
 
  data=pd.concat([data,ichimoku_df],axis=1)
  
  data['ichi_score']=0
 
  ichi_up=data['ichi_score'][data['close']>data['conversion']][data['close']>data['base']]
 
  up1=ichi_up[data['close']>data['spanA']][data['spanA']>data['spanB']]+0.5
 
  up2=ichi_up[data['spanA'].shift(-26)>data['spanB'].shift(-26)][data['spanA'].shift(-25)<=data['spanB'].shift(-25)]+0.5#future
 
  ichi_down=data['ichi_score'][data['close']<data['conversion']][data['close']<data['base']]
 
  down1=ichi_down[data['close']<data['spanA']][data['spanA']<data['spanB']]-0.5
 
  down2=ichi_down[data['spanA'].shift(-26)<data['spanB'].shift(-26)][data['spanA'].shift(-25)>=data['spanB'].shift(-25)]-0.5 #future
 
  up3=data['ichi_score'][data['close']>data['spanA']][data['spanA']>data['spanB']][data['close'].shift()<=data['spanA'].shift()]+0.5
  down3=data['ichi_score'][data['close']<data['spanA']][data['spanA']<data['spanB']][data['close'].shift()>=data['spanA'].shift()]-0.5
 
  ichi_list=[data['ichi_score'],up1,up2,up3,down1,down2,down3]
 
  ichi_scores=pd.concat(ichi_list,axis=1).sum(1)
  
  return ichi_scores.iloc[:-26]

def dday(data):
  window=data.iloc[-75:-50]
  counter=0
  for i in range(len(window)-1):
    if window['close_returns'].iloc[i+1]<=-0.002 and window['volume'].iloc[i+1]>window['volume'].iloc[i]:
      counter+=1

  return -1*(counter>=4)+0
  
def psar_trend(data):  
  return -1*(data['psar'].iloc[-1]>data['close'].iloc[-1])+1*(data['psar'].iloc[-1]<data['close'].iloc[-1])
 
def necklace(data):  #getting the results for the last day of data
  
  long_mfi=mfi10(data)/3
  long_rsi=rsi10(data)/3
  long_cci=cci10(data)/3
  ema_cross=ema_crossback(data)
  psar=psar_reversal(data)
  hma_cross=hma_crossback(data)
  bollinger=bband(data)
  
  dist=dday(data)
    
 
  try:
    moku=ichimoku(data).iloc[-1]
  except:
 
    pass
  
  vol_count=volume_counter(data)
  score_list=[long_mfi,long_rsi,ema_cross,psar,hma_cross,moku,bollinger,long_cci,vol_count,dist]
 
 
  if any(score_list):
    aggregate=sum(score_list)  
  
    short_rsi=rsi2(data)/2
    short_mfi=mfi2(data)/3
    short_cci=cci2(data)/3
    mom=momentum(data)

    tech=[short_rsi,short_mfi,mom,short_cci]
   
    aggregate+=sum(tech)
  
    return aggregate
  
  else:
    return 0
 
def generate_current_views(ticker_list,freq):
  data_dict={}
  views_series=pd.Series(name='views')
  for ticker in ticker_list:
    data=yahooTA(ticker,freq)
    weekly=yahooTA(ticker,'1wk')

    ticker=''.join([char for char in ticker if not char.isdigit()])

    data_dict[ticker]=data
    result=necklace(data)
    
    try:
      weekly_result=necklace(weekly)
    
    except:
      weekly_result=0
      pass
    
    views_series.loc[ticker]=result+weekly_result
 
  return dict(views_series[abs(views_series)>0.2]),data_dict
 
def get_crypto_shares(ticker_list,capital,freq,HRP=False,bl1=False):
  c = cbpro.PublicClient()

  pairs=c.get_products()

  numberless_ticker_list=[''.join([char for char in ticker if not char.isdigit()]) for ticker in ticker_list]

  min_dict={pair['id'].lower():float(pair['base_min_size']) for pair in pairs if (pair['id'].lower() in numberless_ticker_list)}

  _,prime_prices_df=yf_fetch(ticker_list)

  prime_prices_df.columns=[''.join([char for char in ticker if not char.isdigit()]) for ticker in prime_prices_df.columns]

  views_dict,data_dict=generate_current_views(ticker_list,freq)
  views_dict={x:y for x,y in views_dict.items() if y>0}


  if len(views_dict)==1:
    shares_dict={list(views_dict.keys())[-1]:1}
    return shares_dict,data_dict,min_dict

  last_prices=crypto_prices(ticker_list)

  min_required=False
  while min_required==False:
    if HRP:
      weights=HR_Paritize(prime_prices_df[views_dict.keys()],views_dict)
      
    elif bl1:
      bl_weights=Blacklitter1(prime_prices_df[views_dict.keys()],views_dict)
      weights=bl_weights.copy()

    else: 
      bl_weights=Blacklitter(prime_prices_df[views_dict.keys()],views_dict) #2
      weights=bl_weights.copy()
   
    weights_df=pd.Series(weights)
    if len(weights_df[weights_df>0])>0:
      weights_df=weights_df[weights_df>0]
    
    elif len(weights_df[weights_df>0])==0:
      return {},{},{}
      break
      
    if abs(weights_df).sum()!=1:
        
      corrected_df=weights_df/abs(weights_df).sum() 
        
      weights=dict(corrected_df)
      
    else:
      corrected_df=weights_df

    abs_weights=dict(abs(corrected_df))

    shares_dict={''.join([char for char in key if not char.isdigit()]):(abs_weights[key]*capital)/last_prices[key] for key in abs_weights}

    drop_list=[ticker for ticker in shares_dict if shares_dict[ticker]<min_dict[ticker]]

    if len(drop_list)==0:
      min_required=True
    
    else:
      views_dict={key:views_dict[key] for key in views_dict if key not in drop_list}

  if len(shares_dict)==0:
    return {},{},{}
  
  else:  
    return shares_dict,data_dict,min_dict

def crypto_sell_off(auth_client,already_dict,shares_dict):
 
  diff_set=set(already_dict)-(set(shares_dict))
 
  diff_dict={key:already_dict[key] for key in diff_set}
 
  for ticker in diff_dict:
    print('Attempting to sell',ticker)
    print(crypto_market_order(auth_client,ticker,already_dict[ticker],sell=True))

def crypto_market_order(auth_client,ticker,size,sell=False):
  
  if sell:
    instruction='sell'
  
  else:
    instruction='buy'
  
  ticker=''.join([char for char in ticker if not char.isdigit()]).upper()
  
  return auth_client.place_market_order(ticker.upper(),instruction,str(size))

def crypto_stop_order(auth_client,ticker,size,stop_loss):
  limit_price=as_currency(stop_loss-0.02)

  ticker=''.join([char for char in ticker if not char.isdigit()]).upper()
      
  return auth_client.sell(price=str(limit_price),
                      size=str(round(size,2)),
                      order_type='limit',
                      stop='loss',
                      stop_price=str(stop_loss),
                      product_id=ticker)

def crypto_take_profit(auth_client,ticker,size,take_profit):
  limit_price=as_currency(take_profit)-0.01

  ticker=''.join([char for char in ticker if not char.isdigit()]).upper()

  return auth_client.sell(price=str(limit_price),
                      size=str(round(size,2)),
                      order_type='limit',
                      product_id=ticker)

def execute_exchange(ticker_list):
  #try:

    key = '***********************'
    secret = '*********************'
    passphrase = '*******'

    encoded = json.dumps(secret).encode()
    b64secret = base64.b64encode(encoded)
    auth_client = cbpro.AuthenticatedClient(key=key, b64secret=secret, passphrase=passphrase)

    auth_client.cancel_all()

    last_prices=crypto_prices(ticker_list)

    accounts=auth_client.get_accounts()

    already_dict={}

    for account in accounts:
      if float(account['balance'])>0:
        rel_balance=float(account['balance'])
        currency=account['currency']
        
        already_dict[currency.lower()+'-usd']=rel_balance
        
    cash_dict={ticker:already_dict[ticker]*last_prices[ticker] for ticker in already_dict}

    capital=sum(cash_dict.values())*0.8

    shares_dict,data_dict,min_dict=get_crypto_shares(ticker_list,capital,'1d',bl1=False,HRP=True)

    round_dict={ticker:lengthener(ticker,min_dict,size) for ticker,size in shares_dict.items()}

    diff_df=(pd.Series(shares_dict)-pd.Series(already_dict)).dropna()
    diff_df=diff_df[diff_df!=0]

    for ticker in diff_df.index:
      diff_df[ticker]=lengthener(ticker,min_dict,diff_df[ticker])

    print(crypto_sell_off(auth_client,already_dict,shares_dict))

    for ticker in shares_dict:
      print(ticker)
    
      data=data_dict[ticker]
      
      used_data=data[-90:]
      used_data.columns=[col.lower() for col in used_data.columns]
      std=pandas_ta.stdev(used_data['close'],length=2)
      std=norm(std[std<std.quantile(0.8)])
      factor=std.std()
      
      
      atr=pandas_ta.atr(used_data['high'],used_data['low'],used_data['close'],length=2).dropna()

      y,x,_=plt.hist(atr)

      atr= np.mean(int(x[np.where(y == y.max())][0]))

      stop_loss=as_currency(data.close.iloc[-1]-2.5*atr*factor)


      if ticker not in diff_df:
        print('size:',round_dict[ticker])
        print('Attempting to buy',crypto_market_order(auth_client,ticker,round_dict[ticker]))
        print('Attempting to stop',crypto_stop_order(auth_client,ticker,round_dict[ticker],stop_loss))
        
      else:
        #try:
          
          if diff_df[ticker]>0 and diff_df[ticker]>min_dict[ticker]:
            print('size:',diff_df[ticker])
            print('Attempting to buy',crypto_market_order(auth_client,ticker,diff_df[ticker]))
            
            print('Attempting to stop',crypto_stop_order(auth_client,ticker,round_dict[ticker],stop_loss))
            
          elif diff_df[ticker]<0 and abs(diff_df[ticker])>min_dict[ticker]:
            print('size:',diff_df[ticker])
            print('Attempting to buy',crypto_market_order(auth_client,ticker,abs(diff_df[ticker]),sell=True))
            
            print('Attempting to stop',crypto_stop_order(auth_client,ticker,round_dict[ticker],stop_loss))

    accounts=auth_client.get_accounts()

    already_dict={}

    for account in accounts:
      if float(account['balance'])>0:
        rel_balance=float(account['balance'])
        currency=account['currency']
        
        already_dict[currency.lower()+'-usd']=rel_balance

    crypto_stop_correct(auth_client,already_dict,data_dict)
      # except Exception as e:
        # print('error for',e)
          
        #pass
    print(round_dict,already_dict,diff_df)
  
  #except Exception as e:
    #print(e)
    #pass

def crypto_stop_correct(auth_client,already_dict,data_dict):
  already_dict.pop('usd-usd')
  already_dict.pop('usdc-usd')

  orders=list(auth_client.get_orders())

  already_stop={order['product_id'].lower() for order in orders if 'sell' in order.values()}

  to_stop=set(already_dict)-already_stop

  for ticker in to_stop:
    print(ticker,'to stop')
    data=data_dict[ticker]
        
    used_data=data[-90:]
    used_data.columns=[col.lower() for col in used_data.columns]
    std=pandas_ta.stdev(used_data['close'],length=2)
    std=norm(std[std<std.quantile(0.8)])
    factor=std.std()
    
    atr=pandas_ta.atr(used_data['high'],used_data['low'],used_data['close'],length=2).dropna()

    meany=atr.mean()

    y,x,_=plt.hist(atr)

   # atr= np.mean(int(x[np.where(y == y.max())][0]))

    atr= (np.mean(int(x[np.where(y == y.max())][0]))+meany)/2

    reg_stop=data['close'].iloc[-1]*0.04

    stop_loss=max(0.01,as_currency(min(reg_stop,2.5*atr*factor)))

    stop_loss=as_currency(data.close.iloc[-1]-stop_loss)

    message=crypto_stop_order(auth_client,ticker,already_dict[ticker],stop_loss)
    counter=0.01
    
    while 'Insufficient funds' in message.values():
      print(ticker,'again')
      size=already_dict[ticker]-counter
      print(size)
      message=crypto_stop_order(auth_client,ticker,size,stop_loss)
      counter+=0.01

def crypto_prices(ticker_list):
  c = cbpro.PublicClient()
  
  numberless_ticker_list= [''.join([char for char in ticker if not char.isdigit()]) for ticker in ticker_list]

  price_dict={currency:float(c.get_product_ticker(currency)['price']) for currency in numberless_ticker_list}

  price_dict['usd-usd']=1
  price_dict['usdc-usd']=1
  
  return pd.Series(price_dict)

def lengthener(ticker,min_dict,size):
  if min_dict[ticker]==1 or min_dict[ticker]==5:
    return round(size)

  min_length=len(str(min_dict[ticker]).split('.')[-1])

  unit_length=len(str(size).split('.')[-1])

  len_diff=unit_length-min_length
 
  return round(float(str(size)[:-(len_diff-1)]),abs(len_diff-len(str(size).split('.')[-1])))

def profit_take(volatility,stop_loss):
  return abs(3.9*volatility-0.1*stop_loss)

def profit_takes(volatility):
  return abs(1.007211 - 1.743677/2**(volatility/0.5051997))

ticker_list=['eth-usd', 'btc-usd', 'ada-usd', 'doge-usd', 'ltc-usd', 'bch-usd', 'dot1-usd','sol1-usd','uni3-usd','matic-usd','link-usd','etc-usd','xlm-usd','fil-usd']

execute_exchange(ticker_list)